"""Creating custom Metaclass

Metaclass is responsible for generation of classes,
so we can write our own custom metaclasses to modify the way classes
are generated by performing extra actions or injecting code.

To create our custom metaclass, our custom metaclass have to inherit type metaclass and usually override –

    __new__(): It’s a method which is called before __init__().
    It creates the object and return it. We can overide this method to control how the objects are created.
    __init__(): This method just initialize the created object passed as parameter

We can create classes using type() function directly. It can be called in following ways –

    When called with only one argument, it returns the type. We have seen it before in above examples.
    When called with three parameters, it creates a class. Following arguments are passed to it –
        Class name
        Tuple having base classes inherited by class
        Class Dictionary: It serves as local namespace for the class, populated with class methods and variables
"""

class F(type):


    def __call__(cls, *args, **kwargs):
        instance = super(F,cls).__call__(*args,**kwargs)
        return instance

    def __init__(cls,name,base,attr):
        super(F, cls).__init__(name,base,attr)


class G(metaclass=F):
    def __new__(cls, *args, **kwargs):
        return super(G,cls).__new__(cls,*args,**kwargs)

    def __init__(self,*args,**kwargs):
        super(G,self).__init__(*args,**kwargs)


g = G()
print(g)
print(abs(-2))

