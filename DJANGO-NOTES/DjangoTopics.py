"""DJANGO Models"""

"""Django Models is the built-in feature that Django uses to create tables, their fields and various
constraints. Django models simplify the tasks and organize tables into models. 
Generally each model maps to a single database table. 
Each model is a Python class that subclasses django.db.models.Model.

A model is the single,definitive source of information about data. It contains the essential fields 
ad behavior of the data stored. Generally, each model maps to a single data.Whenever we create a Model,
 Delete a Model, or an update anything in any of models.py. We need to 
run two commands makemigrations and migrate. 

MakeMigrations 
python manage.py makemigrations
makemigrations basically generates the SQL commands for preinstalled apps (which can be viewed 
in installed apps in settings.py) and your newly created apps model which you add in installed 
apps. It does not execute those commands in your database file. So tables are not created
after makemigrations.

After applying makemigrations you can see those SQL commands with sqlmigrate which shows 
all the SQL commands which have been generated by makemigrations. 

Migrate 
python manage.py migrate
migrate executes those SQL Commands in the database file. So after executing migrate all the tables 
of your installed apps are created in your database file. 

Django CRUD - Inserting, updating and Deleting Data
Django lets us interact with its database models, i.e. add,delete,modify and query objects, using
database-abstraction API called ORM(Object Relational Mapping). 

1. Adding Objects: To create an object of model Album and save it into database. 
a= GeeksModel(
        title = "GeeksForGeeks",
        description = "A description here",
        img = "geeks/abc.png"
        )
a.save()

a = Album(title = "Divide",artist = "Ed Sheeran",genre = "Pop")
a.save()

2. Retrieving Objects: To retrieve all the objects of a model. 
Geeks.objects.all()
<QuerySet [<GeeksModel: Divide> , <GeeksModel: Abbey Road>] 
the output is a QuerySet, or a set of objects that match the query. The name printed is the output
of the __str__() function.

We can also filter queries using the functions filter(),exclude() and get(). The filter() function returns 
a QuerySet having objects that match the given lookup parameters.

To retrieve objects from your database, construct a QuerySet via Manager on your model class. 

A QUERYSET represents a collection of objects from your database. It can have zero, one and many filters. 
In SQL terms, QuerySet equates to a SELECT statement, and a filter is a limiting clause such as WHERE 

3. Modifying existing objects : 
We can modify an existing object as follows:
a = GeeksModel.objects.get(id=3)
a.title = "pop"
a.save()

4. Deleting objects:
To delete a single object,
a = Album.objects.get(id = 2)
a.save()

Validation on Field in a Model 
Built in Validation in Django models are the default validations that comes predefined to all Django fields.
Every fields comes in with built-in validations from Django validators. For example, IntegerField comes with 
built-in validation that it can only store integer values and that too in a particular range. 

ORM - Inserting, Updating and Deleting Data
Django let us interact with its database models i.e. add, delete, modify and query objects, using a database
abstraction API called ORM(Object Relational Mapping). 

class Album(Models.model):
    title = models.CharField(max_length=100)
    artist = models.CharField(max_length=100)
    genre = models.CharField(max_length=100)
    
    def __str__(self):
        return self.title
            
class Song(Models.model):
    name = models.CharField(max_length=100)
    album = models.ForeignKey(Album,on_delete=models.CASCADE)
    
    def __str__(self):
        return self.name  
        
Model Inheritance :
Model Inheritance in Django works almost identically to the way normal class inheritance works in Python, 
only difference is base class should subclass django.db.Model.model  

The three most common forms of model inheritance in Django are:
1. Multi-table inheritance 
2. Abstract base classes
3. Proxy Methods

Abstract base classes: 
Abstract base classes are useful when you want tp put some common information into a number of other models.
We can write our own base class and put abstract = True in the Meta class. This model will then  not be used  
to create any database table. When, it is used as base class for other models, its fields will be added to those 
child class. 
An example:

from django.db import models

class CommonInfo(Models.model):
        name = models.CharField(max_length=100)
        age = models.CharField(max_length=100)
        
        class Meta:
            abstract = True
            
class Student(Models.model):
        home_group = models.CharField(max_length=100)
        
The Student model will have three fields: name, age, home_group. The CommonInfo model cannot be used 
as a normal Django model, since it is an abstract base class. It does not generate a database table or 
have a manager, and cannot be instantiated or saved directly. 

Fields inherited from abstract base classes can be overridden with another field or value, or be removed with 
None. It provides a way to factor out common information at the Python Level. 

Meta Inheritance 

When an abstract base class is created, Django makes any meta inner class declared in the base class 
available as an attribute. If a child class does not declare its own Meta class, it will inherit the 
parent's Meta. If the child wants to extend the parent's Meta class, it can subclass it. 

from django.db import models
    
    class CommonInfo(models.Model):
            # ..
            
            class Meta:
                abstract = True
                ordering = ['name']
                
   class Student(CommonInfo):
            #..
            
            class Meta(CommonInfo.Meta):
                    db_table = 'student_info'
                    
Django does make one adjustment to the Meta class of an abstract base class: before installing the Meta
attribute, it sets abstract = False. This means that children of abstract base classes don't automatically
becomes abstract classes themselves.Of course, you can make an abstract base class that inherits from another
abstract base class. You just need to remember to explicitly set abstract = True each time. 

Some attributes won't take make sense to include in the Meta class of an abstract base class. For example, 
including db_table would mean that all the child classes(the ones that don't specify their own Meta) would 
use the same database table.      

Multi-table inheritance 
The second type of model inheritance supported by Django is when each model in the hierarchy is a model 
all by itself. Each model corresponds to its own database table and can be queried and created individually. 
The inheritance relationship introduces links between the child model and each of its parents 
(via an automatically-created OneToOneField).

from django.db import models

class Place(models.Model):
    name = models.CharField(max_length=100)
    address = models.CharField(max_length=100)
    
class Restaurant(models.Model):
    serves_hot_dogs = models.CharField(max_length=100)
    serves_pizza = models.CharField(max_length=100)
    
                                    
            

                                           


        
        










"""